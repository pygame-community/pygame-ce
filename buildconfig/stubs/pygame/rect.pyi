import sys
from typing import (
    Dict,
    Iterator,
    List,
    Sequence,
    Tuple,
    TypeVar,
    Union,
    overload,
    Callable,
    Any,
    Optional,
)

from ._common import Coordinate, Literal, RectValue

if sys.version_info >= (3, 9):
    from collections.abc import Collection
else:
    from typing import Collection

_K = TypeVar("_K")
_V = TypeVar("_V")
_T = TypeVar("_T")

# Rect confirms to the Collection ABC, since it also confirms to
# Sized, Iterable and Container ABCs
class Rect(Collection[int]):
    x: int
    y: int
    top: int
    left: int
    bottom: int
    right: int
    @property
    def topleft(self) -> Tuple[int, int]: ...
    @topleft.setter
    def topleft(self, value: Coordinate) -> None:
        """The top left corner of the rect. Floats will be truncated to ints"""
        ...
    @property
    def bottomleft(self) -> Tuple[int, int]: ...
    @bottomleft.setter
    def bottomleft (self, value: Coordinate) -> None:
        """The bottom left corner of the rect. Floats will be truncated to ints"""
        ...
    @property
    def topright(self) -> Tuple[int, int]: ...
    @topright.setter
    def topright(self, value: Coordinate) -> None:
        """The top right corner of the rect. Floats will be truncated to ints"""
        ...
    @property
    def bottomright(self) -> Tuple[int, int]: ...
    @bottomright.setter
    def bottomright(self, value: Coordinate) -> None:
        """The bottom right corner of the rect. Floats will be truncated to ints"""
        ...
    @property
    def midtop(self) -> Tuple[int, int]: ...
    @midtop.setter
    def midtop(self, value: Coordinate) -> None:
        """The middle of the top edge of the rect. Floats will be truncated to ints"""
        ...
    @property
    def midleft(self) -> Tuple[int, int]: ...
    @midleft.setter
    def midleft(self, value: Coordinate) -> None:
        """The middle of the left edge of the rect. Floats will be truncated to ints"""
        ...
    @property
    def midbottom(self) -> Tuple[int, int]: ...
    @midbottom.setter
    def midbottom(self, value: Coordinate) -> None:
        """The middle of the bottom edge of the rect. Floats will be truncated to ints"""
        ...
    @property
    def midright(self) -> Tuple[int, int]: ...
    @midright.setter
    def midright(self, value: Coordinate) -> None:
        """The middle of the right edge of the rect. Floats will be truncated to ints"""
        ...
    @property
    def center(self) -> Tuple[int, int]: ...
    @center.setter
    def center(self, value: Coordinate) -> None:
        """The center of the rect. Floats will be truncated to ints"""
        ...
    centerx: int
    centery: int
    @property
    def size(self) -> Tuple[int, int]: ...
    @size.setter
    def size(self, value: Coordinate) -> None:
        """The size of the rect. Floats will be truncated to ints"""
        ...
    width: int
    height: int
    w: int
    h: int
    __hash__: None  # type: ignore
    __safe_for_unpickling__: Literal[True]
    @overload
    def __init__(
        self, left: float, top: float, width: float, height: float
    ) -> None: ...
    @overload
    def __init__(self, left_top: Coordinate, width_height: Coordinate) -> None: ...
    @overload
    def __init__(self, single_arg: RectValue) -> None: ...
    def __len__(self) -> Literal[4]: ...
    def __iter__(self) -> Iterator[int]: ...
    @overload
    def __getitem__(self, i: int) -> int: ...
    @overload
    def __getitem__(self, s: slice) -> List[int]: ...
    @overload
    def __setitem__(self, key: int, value: int) -> None: ...
    @overload
    def __setitem__(self, key: slice, value: Union[int, Rect]) -> None: ...
    def __copy__(self) -> Rect: ...
    copy = __copy__
    @overload
    def move(self, x: float, y: float) -> Rect: ...
    @overload
    def move(self, move_by: Coordinate) -> Rect: ...
    @overload
    def move_ip(self, x: float, y: float) -> None: ...
    @overload
    def move_ip(self, move_by: Coordinate) -> None: ...
    @overload
    def inflate(self, x: float, y: float) -> Rect: ...
    @overload
    def inflate(self, inflate_by: Coordinate) -> Rect: ...
    @overload
    def inflate_ip(self, x: float, y: float) -> None: ...
    @overload
    def inflate_ip(self, inflate_by: Coordinate) -> None: ...
    @overload
    def update(self, left: float, top: float, width: float, height: float) -> None: ...
    @overload
    def update(self, left_top: Coordinate, width_height: Coordinate) -> None: ...
    @overload
    def update(self, single_arg: RectValue) -> None: ...
    @overload
    def clamp(self, rect: RectValue) -> Rect: ...
    @overload
    def clamp(self, left_top: Coordinate, width_height: Coordinate) -> Rect: ...
    @overload
    def clamp(self, left: float, top: float, width: float, height: float) -> Rect: ...
    @overload
    def clamp_ip(self, rect: RectValue) -> None: ...
    @overload
    def clamp_ip(self, left_top: Coordinate, width_height: Coordinate) -> None: ...
    @overload
    def clamp_ip(
        self, left: float, top: float, width: float, height: float
    ) -> None: ...
    @overload
    def clip(self, rect: RectValue) -> Rect: ...
    @overload
    def clip(self, left_top: Coordinate, width_height: Coordinate) -> Rect: ...
    @overload
    def clip(self, left: float, top: float, width: float, height: float) -> Rect: ...
    @overload
    def clipline(
        self, x1: float, x2: float, x3: float, x4: float
    ) -> Union[Tuple[Tuple[int, int], Tuple[int, int]], Tuple[()]]: ...
    @overload
    def clipline(
        self, first_coordinate: Coordinate, second_coordinate: Coordinate
    ) -> Union[Tuple[Tuple[int, int], Tuple[int, int]], Tuple[()]]: ...
    @overload
    def clipline(
        self, rect_arg: RectValue
    ) -> Union[Tuple[Tuple[int, int], Tuple[int, int]], Tuple[()]]: ...
    @overload
    def union(self, rect: RectValue) -> Rect: ...
    @overload
    def union(self, left_top: Coordinate, width_height: Coordinate) -> Rect: ...
    @overload
    def union(self, left: float, top: float, width: float, height: float) -> Rect: ...
    @overload
    def union_ip(self, rect: RectValue) -> None: ...
    @overload
    def union_ip(self, left_top: Coordinate, width_height: Coordinate) -> None: ...
    @overload
    def union_ip(
        self, left: float, top: float, width: float, height: float
    ) -> None: ...
    def unionall(self, rect: Sequence[RectValue]) -> Rect: ...
    def unionall_ip(self, rect_sequence: Sequence[RectValue]) -> None: ...
    @overload
    def fit(self, rect: RectValue) -> Rect: ...
    @overload
    def fit(self, left_top: Coordinate, width_height: Coordinate) -> Rect: ...
    @overload
    def fit(self, left: float, top: float, width: float, height: float) -> Rect: ...
    def normalize(self) -> None: ...
    def __contains__(self, rect: Union[RectValue, int]) -> bool: ...  # type: ignore[override]
    @overload
    def contains(self, rect: RectValue) -> bool: ...
    @overload
    def contains(self, left_top: Coordinate, width_height: Coordinate) -> bool: ...
    @overload
    def contains(
        self, left: float, top: float, width: float, height: float
    ) -> bool: ...
    @overload
    def collidepoint(self, x: float, y: float) -> bool: ...
    @overload
    def collidepoint(self, x_y: Coordinate) -> bool: ...
    @overload
    def colliderect(self, rect: RectValue) -> bool: ...
    @overload
    def colliderect(self, left_top: Coordinate, width_height: Coordinate) -> bool: ...
    @overload
    def colliderect(
        self, left: float, top: float, width: float, height: float
    ) -> bool: ...
    def collidelist(self, rect_list: Sequence[RectValue]) -> int: ...
    def collidelistall(self, rect_list: Sequence[RectValue]) -> List[int]: ...
    def collideobjectsall(
        self, objects: Sequence[_T], key: Optional[Callable[[_T], RectValue]] = None
    ) -> List[_T]: ...
    def collideobjects(
        self, objects: Sequence[_T], key: Optional[Callable[[_T], RectValue]] = None
    ) -> Optional[_T]: ...
    # Also undocumented: the dict collision methods take a 'values' argument
    # that defaults to False. If it is False, the keys in rect_dict must be
    # Rect-like; otherwise, the values must be Rects.
    @overload
    def collidedict(
        self, rect_dict: Dict[RectValue, _V], values: bool = ...
    ) -> Tuple[RectValue, _V]: ...
    @overload
    def collidedict(
        self, rect_dict: Dict[_K, "Rect"], values: bool
    ) -> Tuple[_K, "Rect"]: ...
    @overload
    def collidedictall(
        self, rect_dict: Dict[RectValue, _V], values: bool = ...
    ) -> List[Tuple[RectValue, _V]]: ...
    @overload
    def collidedictall(
        self, rect_dict: Dict[_K, "Rect"], values: bool
    ) -> List[Tuple[_K, "Rect"]]: ...

class FRect(Collection[float]):
    x: float
    y: float
    top: float
    left: float
    bottom: float
    right: float
    @property
    def topleft(self) -> Tuple[float, float]: ...
    @topleft.setter
    def topleft(self, value: Coordinate) -> None:
        """The top left corner of the rect"""
        ...
    @property
    def bottomleft(self) -> Tuple[float, float]: ...
    @bottomleft.setter
    def bottomleft (self, value: Coordinate) -> None:
        """The bottom left corner of the rect"""
        ...
    @property
    def topright(self) -> Tuple[float, float]: ...
    @topright.setter
    def topright(self, value: Coordinate) -> None:
        """The top right corner of the rect"""
        ...
    @property
    def bottomright(self) -> Tuple[float, float]: ...
    @bottomright.setter
    def bottomright(self, value: Coordinate) -> None:
        """The bottom right corner of the rect"""
        ...
    @property
    def midtop(self) -> Tuple[float, float]: ...
    @midtop.setter
    def midtop(self, value: Coordinate) -> None:
        """The middle of the top edge of the rect"""
        ...
    @property
    def midleft(self) -> Tuple[float, float]: ...
    @midleft.setter
    def midleft(self, value: Coordinate) -> None:
        """The middle of the left edge of the rect"""
        ...
    @property
    def midbottom(self) -> Tuple[float, float]: ...
    @midbottom.setter
    def midbottom(self, value: Coordinate) -> None:
        """The middle of the bottom edge of the rect"""
        ...
    @property
    def midright(self) -> Tuple[float, float]: ...
    @midright.setter
    def midright(self, value: Coordinate) -> None:
        """The middle of the right edge of the rect"""
        ...
    @property
    def center(self) -> Tuple[float, float]: ...
    @center.setter
    def center(self, value: Coordinate) -> None:
        """The center of the rect"""
        ...
    centerx: float
    centery: float
    @property
    def size(self) -> Tuple[float, float]: ...
    @size.setter
    def size(self, value: Coordinate) -> None:
        """The size of the rect"""
        ...
    width: float
    height: float
    w: float
    h: float
    __hash__: None  # type: ignore
    __safe_for_unpickling__: Literal[True]
    @overload
    def __init__(
        self, left: float, top: float, width: float, height: float
    ) -> None: ...
    @overload
    def __init__(self, left_top: Coordinate, width_height: Coordinate) -> None: ...
    @overload
    def __init__(self, single_arg: RectValue) -> None: ...
    def __len__(self) -> Literal[4]: ...
    def __iter__(self) -> Iterator[float]: ...
    @overload
    def __getitem__(self, i: int) -> float: ...
    @overload
    def __getitem__(self, s: slice) -> List[float]: ...
    @overload
    def __setitem__(self, key: int, value: float) -> None: ...
    @overload
    def __setitem__(self, key: slice, value: Union[float, FRect]) -> None: ...
    def __copy__(self) -> FRect: ...
    copy = __copy__
    @overload
    def move(self, x: float, y: float) -> FRect: ...
    @overload
    def move(self, move_by: Coordinate) -> FRect: ...
    @overload
    def move_ip(self, x: float, y: float) -> None: ...
    @overload
    def move_ip(self, move_by: Coordinate) -> None: ...
    @overload
    def inflate(self, x: float, y: float) -> FRect: ...
    @overload
    def inflate(self, inflate_by: Coordinate) -> FRect: ...
    @overload
    def inflate_ip(self, x: float, y: float) -> None: ...
    @overload
    def inflate_ip(self, inflate_by: Coordinate) -> None: ...
    @overload
    def update(self, left: float, top: float, width: float, height: float) -> None: ...
    @overload
    def update(self, left_top: Coordinate, width_height: Coordinate) -> None: ...
    @overload
    def update(self, single_arg: RectValue) -> None: ...
    @overload
    def clamp(self, rect: RectValue) -> FRect: ...
    @overload
    def clamp(self, left_top: Coordinate, width_height: Coordinate) -> FRect: ...
    @overload
    def clamp(self, left: float, top: float, width: float, height: float) -> FRect: ...
    @overload
    def clamp_ip(self, rect: RectValue) -> None: ...
    @overload
    def clamp_ip(self, left_top: Coordinate, width_height: Coordinate) -> None: ...
    @overload
    def clamp_ip(
        self, left: float, top: float, width: float, height: float
    ) -> None: ...
    @overload
    def clip(self, rect: RectValue) -> FRect: ...
    @overload
    def clip(self, left_top: Coordinate, width_height: Coordinate) -> FRect: ...
    @overload
    def clip(self, left: float, top: float, width: float, height: float) -> FRect: ...
    @overload
    def clipline(
        self, x1: float, x2: float, x3: float, x4: float
    ) -> Union[Tuple[Tuple[float, float], Tuple[float, float]], Tuple[()]]: ...
    @overload
    def clipline(
        self, first_coordinate: Coordinate, second_coordinate: Coordinate
    ) -> Union[Tuple[Tuple[float, float], Tuple[float, float]], Tuple[()]]: ...
    @overload
    def clipline(
        self, rect_arg: RectValue
    ) -> Union[Tuple[Tuple[float, float], Tuple[float, float]], Tuple[()]]: ...
    @overload
    def union(self, rect: RectValue) -> FRect: ...
    @overload
    def union(self, left_top: Coordinate, width_height: Coordinate) -> FRect: ...
    @overload
    def union(self, left: float, top: float, width: float, height: float) -> FRect: ...
    @overload
    def union_ip(self, rect: RectValue) -> None: ...
    @overload
    def union_ip(self, left_top: Coordinate, width_height: Coordinate) -> None: ...
    @overload
    def union_ip(
        self, left: float, top: float, width: float, height: float
    ) -> None: ...
    def unionall(self, rect: Sequence[RectValue]) -> FRect: ...
    def unionall_ip(self, rect_sequence: Sequence[RectValue]) -> None: ...
    @overload
    def fit(self, rect: RectValue) -> FRect: ...
    @overload
    def fit(self, left_top: Coordinate, width_height: Coordinate) -> FRect: ...
    @overload
    def fit(self, left: float, top: float, width: float, height: float) -> FRect: ...
    def normalize(self) -> None: ...
    def __contains__(self, rect: Union[RectValue, float]) -> bool: ...  # type: ignore[override]
    @overload
    def contains(self, rect: RectValue) -> bool: ...
    @overload
    def contains(self, left_top: Coordinate, width_height: Coordinate) -> bool: ...
    @overload
    def contains(
        self, left: float, top: float, width: float, height: float
    ) -> bool: ...
    @overload
    def collidepoint(self, x: float, y: float) -> bool: ...
    @overload
    def collidepoint(self, x_y: Coordinate) -> bool: ...
    @overload
    def colliderect(self, rect: RectValue) -> bool: ...
    @overload
    def colliderect(self, left_top: Coordinate, width_height: Coordinate) -> bool: ...
    @overload
    def colliderect(
        self, left: float, top: float, width: float, height: float
    ) -> bool: ...
    def collidelist(self, rect_list: Sequence[RectValue]) -> float: ...
    def collidelistall(self, rect_list: Sequence[RectValue]) -> List[float]: ...
    def collideobjectsall(
        self, objects: Sequence[_T], key: Optional[Callable[[_T], RectValue]] = None
    ) -> List[_T]: ...
    def collideobjects(
        self, objects: Sequence[_T], key: Optional[Callable[[_T], RectValue]] = None
    ) -> Optional[_T]: ...
    # Also undocumented: the dict collision methods take a 'values' argument
    # that defaults to False. If it is False, the keys in rect_dict must be
    # Rect-like; otherwise, the values must be Rects.
    @overload
    def collidedict(
        self, rect_dict: Dict[RectValue, _V], values: bool = ...
    ) -> Tuple[RectValue, _V]: ...
    @overload
    def collidedict(
        self, rect_dict: Dict[_K, "FRect"], values: bool
    ) -> Tuple[_K, "FRect"]: ...
    @overload
    def collidedictall(
        self, rect_dict: Dict[RectValue, _V], values: bool = ...
    ) -> List[Tuple[RectValue, _V]]: ...
    @overload
    def collidedictall(
        self, rect_dict: Dict[_K, "FRect"], values: bool
    ) -> List[Tuple[_K, "FRect"]]: ...

RectType = Rect
FRectType = FRect

